# 意图

**单例模式**是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点

# 解决问题

1. **保证一个类只有一个实例**

   - 控制某些共享资源 （例如数据库或文件） 的访问权限

   - 日志写入

   - 它的运作方式是这样的： 如果你创建了一个对象， 同时过一会儿后你决定再创建一个新对象， 此时你会获得之前已创建的对象， 而不是一个新对象。

     注意， 普通构造函数无法实现上述行为， 因为构造函数的设计决定了它**必须**总是返回一个新对象

2. **为该实例提供一个全局访问节点**

   问题：

   ​	我们用过的那些存储重要对象的**全局变量**吗？ 它们在使用上十分方便， 但同时也非常不安全， 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃

   解决：

   ​    单例模式也允许在程序的任何地方访问特定对象。 但是它可以**保护该实例不被其他代码覆盖**。

   还有一点： 你不会希望解决同一个问题的代码分散在程序各处的。 因此更好的方式是将其放在同一个类中， 特别是当其他代码已经依赖这个类时更应该如此

   

   # 使用场景

   - **程序中的某个类对于所有客户端只有一个可用的实例，可以使用单例模式**
     - 单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。
   - **如果你需要更加严格地控制全局变量**， **可以使用单例模式**
     - 单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。
     - 注意， 你可以随时调整限制并设定生成单例实例的数量， 只需修改 `获取实例`方法， 即 getInstance 中的代码即可实现。

   # 实现步骤

   1. 在类中添加一个私有静态成员变量用于保存单例实例。

   2. 声明一个公有静态构建方法用于获取单例实例。

   3. 在静态方法中实现"延迟初始化"。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。

   4. 将类的构造函数设为私有。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。

   5. 检查客户端代码， 将对单例的构造函数的调用替换为对其静态构建方法的调用。




​      

